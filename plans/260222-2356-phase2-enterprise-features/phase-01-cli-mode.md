---
title: "Phase 01: CLI Mode (F1)"
status: complete
priority: P1
effort: 1.5d
---

# Phase 01: CLI Mode (F1)

## Context Links
- Work context: `sekkei/packages/mcp-server/`
- Existing bin: `bin/init.js`, `bin/setup.js`
- Tool handlers: `src/tools/{generate,validate,export,chain-status,glossary}.ts`
- Tool registry: `src/tools/index.ts` → `registerAllTools()`
- Config: `src/config.ts` → `loadConfig()`

## Overview
- **Priority:** P1 — must wrap all other Phase 2 tools
- **Status:** pending; depends on phases 02–07 completion
- **Goal:** `npx sekkei <subcommand>` standalone CLI reusing existing MCP tool handlers directly (no MCP transport)

## Key Insights
- Handlers are pure async functions; MCP transport is just a wrapper — safe to call handlers directly
- `citty` is ESM-native (`defineCommand`, `runMain`), avoids CommonJS compat issues
- stdout is sacred in MCP mode — CLI must never pollute stdout with logs; use stderr
- `bin/cli.js` must be a thin shim; actual logic in `src/cli/` modules
- Init wizard (`bin/init.js`) already uses `@clack/prompts` — CLI can reuse same pattern

## Requirements
- **Functional:**
  - `sekkei generate <doc-type> [--feature <name>] [--input <path>]`
  - `sekkei validate [--all] [--doc-type <type>] [--manifest <path>]`
  - `sekkei export --format <xlsx|pdf|docx> [--template <path>]`
  - `sekkei status` — print chain status from sekkei.config.yaml
  - `sekkei init` — delegate to existing `bin/init.js` logic
  - `sekkei glossary [--extract] [--term <word>]`
- **Non-functional:** ESM, help text auto-generated by citty, exit codes (0=ok, 1=error)

## Architecture

```
bin/cli.js          ← shim: import src/cli/main.js, runMain()
src/cli/
  main.ts           ← defineCommand root + subcommands map
  commands/
    generate.ts     ← calls tool handler directly
    validate.ts
    export.ts
    status.ts
    glossary.ts
  cli-logger.ts     ← pino to stderr (fd 2)
  config-loader.ts  ← read sekkei.config.yaml, map to tool args
```

Tool handler call pattern (no MCP server needed):
```ts
import { handleGenerate } from "../tools/generate.js";
const result = await handleGenerate({ doc_type, input_content, ... });
```

Each tool handler must expose a named export (currently wrapped in `registerXxx(server)`). Refactor pattern: extract pure handler function, keep `registerXxx` as thin wrapper calling it.

## Related Code Files

**Modify:**
- `src/tools/generate.ts` — extract `handleGenerateDocument()` pure function
- `src/tools/validate.ts` — extract `handleValidateDocument()` pure function
- `src/tools/export.ts` — extract `handleExportDocument()` pure function
- `src/tools/chain-status.ts` — extract `handleChainStatus()` pure function
- `src/tools/glossary.ts` — extract `handleGlossary()` pure function
- `package.json` — add `"sekkei": "bin/cli.js"` to `bin`, add `citty` dep

**Create:**
- `bin/cli.js` — ESM shim
- `src/cli/main.ts` — citty root command
- `src/cli/commands/generate.ts`
- `src/cli/commands/validate.ts`
- `src/cli/commands/export.ts`
- `src/cli/commands/status.ts`
- `src/cli/commands/glossary.ts`
- `src/cli/cli-logger.ts`
- `src/cli/config-loader.ts`

## Implementation Steps

1. Add `citty` to dependencies: `npm install citty`
2. Refactor each tool: extract pure `handle*()` from `registerXxx()` wrapper
3. Create `src/cli/cli-logger.ts` — pino logger writing to fd 2 only
4. Create `src/cli/config-loader.ts` — parse `sekkei.config.yaml` via existing `yaml` package
5. Create 5 command modules in `src/cli/commands/` — call extracted handlers
6. Create `src/cli/main.ts` — citty `defineCommand` root with subcommands
7. Create `bin/cli.js` — `#!/usr/bin/env node` shim importing `dist/cli/main.js`
8. Add `"sekkei": "bin/cli.js"` to `package.json bin`
9. Build and smoke-test: `node bin/cli.js status`, `node bin/cli.js --help`
10. Add CLI integration tests in `tests/integration/cli.test.ts`

## Todo List

- [x] Install `citty` dep
- [x] Extract `handleGenerateDocument()` from generate.ts
- [x] Extract `handleValidateDocument()` from validate.ts
- [x] Extract `handleExportDocument()` from export.ts
- [x] Extract `handleChainStatus()` from chain-status.ts
- [x] Extract `handleGlossary()` from glossary.ts
- [x] Extract `handleValidateChain()` from validate-chain.ts
- [x] Create `src/cli/cli-logger.ts`
- [x] Create `src/cli/config-loader.ts`
- [x] Create 5 command modules
- [x] Create `src/cli/main.ts`
- [x] Create `bin/cli.js` shim
- [x] Update `package.json` bin
- [x] Add integration tests (6 tests)
- [x] Run `npm run lint` — no errors
- [x] Run `npm test` — 215 pass (209 original + 6 CLI integration)

## Success Criteria
- `npx sekkei --help` prints subcommand list
- `npx sekkei generate basic-design --feature sales` produces instructions to stdout
- `npx sekkei validate --doc-type requirements` reads from config, reports issues
- `npx sekkei export --format xlsx` produces file
- All 142+ existing tests pass; ≥3 new CLI integration tests

## Risk Assessment
- **Handler refactor breaks existing MCP tests** — mitigate: keep `registerXxx` wrapper unchanged, only extract logic to separate function
- **citty ESM compatibility** — mitigate: citty is explicitly ESM-native; verify with `node --input-type=module`
- **stdout contamination** — mitigate: audit all `console.log` in handlers, replace with logger

## Security Considerations
- Path inputs validated with same Zod regex refinements used in MCP tools
- `sekkei init` delegates to existing hardened wizard — no new attack surface
- CLI reads config via `loadProjectConfig()` — existing path containment checks apply

## Next Steps
- After phase 01: update `sekkei/skills/sekkei/SKILL.md` to reference CLI commands
- Document CLI usage in `docs/`
