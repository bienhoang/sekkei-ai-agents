/**
 * Project-type-specific instructions for architecture-pattern project types.
 * Covers: microservice, hybrid, event-driven, ai-ml
 * See: project-type-instructions.ts for base types (saas, mobile, batch, etc.)
 */
import type { DocType, ProjectType } from "../types/documents.js";

export const PROJECT_TYPE_INSTRUCTIONS_ARCH: Partial<Record<ProjectType, Partial<Record<DocType, string>>>> = {
  microservice: {
    "detail-design": [
      "## Project Type: Microservice Detail Design",
      "- Per-service class design: each service has own Repository, Service, Controller layers",
      "- gRPC proto definitions: include message types and service interfaces in API詳細仕様",
      "- Saga orchestrator classes: SagaCoordinator, CompensationHandler for distributed transactions",
      "- Circuit breaker patterns: RetryPolicy, CircuitBreakerConfig per downstream dependency",
    ].join("\n"),
    "basic-design": [
      "## Project Type: Microservice",
      "### System Architecture (Section 2)",
      "- Generate SEPARATE system architecture diagrams per service domain",
      "- Include inter-service communication diagram (Mermaid flowchart with service nodes)",
      "- Specify communication protocols per service pair (REST, gRPC, message queue)",
      "",
      "### DB Design (Section 7)",
      "- Generate SEPARATE ER diagrams per service domain (bounded context)",
      "- Each service owns its database — no cross-service direct DB access",
      "- Include data consistency strategy (eventual consistency, saga pattern)",
      "",
      "### External Interface (Section 8)",
      "- Distinguish internal APIs (service-to-service) vs external APIs (client-facing)",
      "- Internal APIs: add columns for circuit breaker, retry policy, timeout",
      "- API gateway routing table if applicable",
      "",
      "### Additional Section: サービス間通信設計",
      "Add section after Section 8:",
      "| サービス | 通信先 | プロトコル | 同期/非同期 | リトライ方針 | サーキットブレーカー |",
    ].join("\n"),
    requirements: [
      "## Project Type: Microservice",
      "Include service decomposition strategy in scope.",
      "Each service boundary should map to functional requirements grouping.",
      "Add NFRs for: inter-service latency, distributed tracing, service mesh overhead.",
    ].join("\n"),
    "security-design": [
      "## Project Type: Microservice Security",
      "- mTLS for inter-service communication",
      "- Service mesh security policies (Istio/Linkerd authorization)",
      "- Centralized authentication at API gateway level",
      "- Per-service rate limiting and DDoS protection",
      "- Container image scanning and runtime security",
      "- Network policies (pod-to-pod isolation)",
      "- Secret injection via Vault/KMS (no env var secrets)",
    ].join("\n"),
  },
  hybrid: {
    "basic-design": [
      "## Project Type: Hybrid (Mobile + Web)",
      "### Screen Design (Section 5)",
      "- Use platform prefixes: SCR-W-001 (Web), SCR-M-001 (Mobile)",
      "- Generate SEPARATE screen transition diagrams per platform",
      "- Include responsive design breakpoints: desktop (1200px+), tablet (768-1199px), mobile (<768px)",
      "",
      "### Platform-Specific UX",
      "- Web: keyboard shortcuts, breadcrumb navigation, browser back behavior",
      "- Mobile: swipe gestures, pull-to-refresh, bottom navigation pattern",
      "- Shared: common business logic, API contracts identical across platforms",
      "",
      "### External Interface (Section 8)",
      "- Push notification spec (Firebase/APNs) for mobile",
      "- WebSocket/SSE spec for web real-time updates",
      "- Shared REST API backend (single API serves both platforms)",
    ].join("\n"),
    "detail-design": [
      "## Project Type: Hybrid Detail Design",
      "- Shared business logic layer: platform-agnostic Service/UseCase classes",
      "- Platform adapters: WebPlatformAdapter, MobilePlatformAdapter implementing shared interface",
      "- Responsive component design: BreakpointManager, LayoutAdapter per platform prefix (W-/M-)",
    ].join("\n"),
    requirements: [
      "## Project Type: Hybrid (Mobile + Web)",
      "Include platform-specific requirements: web browser support matrix, mobile OS versions.",
      "Define shared vs platform-specific features clearly.",
      "Add responsive design requirements: breakpoints, touch vs mouse interaction differences.",
      "Specify offline capabilities per platform if applicable.",
    ].join("\n"),
    "security-design": [
      "## Project Type: Hybrid Security",
      "- Web security: CSP headers, XSS prevention, CSRF tokens, secure cookies",
      "- Mobile security: certificate pinning, secure storage, biometric auth",
      "- Shared API security: OAuth2 with platform-specific flows (PKCE for mobile, authorization code for web)",
      "- Session management: platform-aware token refresh, concurrent session limits",
    ].join("\n"),
  },
  "event-driven": {
    "detail-design": [
      "## Project Type: Event-Driven Detail Design",
      "- Event handler classes: EventConsumer, EventProducer, EventRouter per domain event",
      "- Dead-letter handling: DLQProcessor, RetryScheduler, PoisonMessageHandler",
      "- Event schema versioning: EventEnvelope with version field, SchemaRegistry adapter",
    ].join("\n"),
    "basic-design": [
      "## Project Type: Event-Driven",
      "### Additional Section: イベント設計 (Event Design)",
      "Add after Section 8. Include:",
      "| イベントID | イベント名 | プロデューサー | コンシューマー | ペイロード | 順序保証 |",
      "",
      "### Additional Section: メッセージフロー (Message Flow)",
      "- Mermaid sequence diagram showing event flow between services/components",
      "- Message queue/broker topology (Kafka topics, RabbitMQ exchanges, SQS queues)",
      "",
      "### System Architecture (Section 2)",
      "- Include message broker/event bus in architecture diagram",
      "- Show async communication paths with dashed arrows",
      "",
      "### DB Design (Section 7)",
      "- CQRS: if applicable, show read model and write model separately",
      "- Event store table (if event sourcing pattern used)",
      "",
      "### Non-Functional Design (Section 9)",
      "- Message delivery guarantees (at-least-once, exactly-once)",
      "- Dead letter queue strategy",
      "- Event replay/reprocessing capability",
    ].join("\n"),
    requirements: [
      "## Project Type: Event-Driven",
      "Include event-specific NFRs: message throughput, end-to-end latency, delivery guarantees.",
      "Define event schema versioning strategy in constraints section.",
    ].join("\n"),
    "security-design": [
      "## Project Type: Event-Driven Security",
      "- Message-level encryption and signing for sensitive event payloads",
      "- Topic/queue access control: per-service publish/subscribe permissions",
      "- Dead letter queue security: encrypted DLQ, access audit for reprocessed messages",
      "- Event schema validation at ingress to prevent injection via malformed payloads",
      "- Consumer authentication: mTLS or token-based auth for message broker connections",
    ].join("\n"),
  },
  "ai-ml": {
    "detail-design": [
      "## Project Type: AI/ML Detail Design",
      "- Model serving classes: ModelLoader, InferenceEngine, PredictionService, ModelVersionRouter",
      "- Feature engineering: FeatureExtractor, FeatureStore adapter, FeatureValidator",
      "- Inference pipeline: PreProcessor, PostProcessor, ResultFormatter with latency budgets per step",
    ].join("\n"),
    "basic-design": [
      "## Project Type: AI/ML",
      "### External Interface (Section 8)",
      "- ML model serving endpoints: distinguish from regular REST APIs",
      "- Include inference latency SLA, model version header, A/B routing",
      "- Input validation for model inputs (schema, data type, value ranges)",
      "",
      "### Additional Section: ML パイプライン設計",
      "Add after Section 8 (if training pipeline is in scope):",
      "- Training data source → preprocessing → model training → evaluation → deployment flow",
      "- Model registry and versioning strategy",
      "- Feature store integration if applicable",
      "",
      "### Non-Functional Design (Section 9)",
      "- Model inference latency targets (p50, p95, p99)",
      "- GPU/compute resource requirements",
      "- Model monitoring: drift detection, accuracy degradation alerts",
      "- Explainability requirements (SHAP/LIME if regulated industry)",
    ].join("\n"),
    requirements: [
      "## Project Type: AI/ML",
      "Include ML-specific NFRs: inference latency, model accuracy thresholds, retraining frequency.",
      "Address ethical considerations: bias detection, explainability requirements.",
    ].join("\n"),
    "security-design": [
      "## Project Type: AI/ML Security",
      "- Model supply chain security: model provenance, signed model artifacts",
      "- Adversarial attack protection: input validation against prompt injection, data poisoning",
      "- Training data security: PII scrubbing, data lineage, access control for training datasets",
      "- Model output filtering: harmful content detection, confidence threshold enforcement",
      "- API security for inference endpoints: rate limiting, input size limits, timeout controls",
      "- Model explainability audit trail: log prediction inputs/outputs for regulated use cases",
    ].join("\n"),
  },
};
